#-*- coding: utf-8 -*-

#from rdflib import Graph, URIRef, BNode, Literal, Namespace
#from rdflib.namespace import RDF, FOAF, OWL, RDFS
#from rdflib.util import guess_format

from rdf import *

def remove_overlap(l):
    return list(set(l))

def print_graph(graph):
    for subj, pred, obj in graph:
        print u"({0}, {1}, {2})".format(subj, pred, obj)

class Path(object):
    def __init__(self, triples_list):
        self.triples_list = triples_list

        if self.is_this_path() == False: raise Exception

    def is_this_path(self):
        triples_list_length = len(self.triples_list)
        for i in range(triples_list_length):
            subj1, pred1, obj1 = self.triples_list[i]

            if i+1 < triples_list_length: 
                subj2, pred2, obj2 = self.triples_list[i+1]

            if i+2 < triples_list_length: 
                subj3, pred3, obj3 = self.triples_list[i+1]

            # is it connected?
            if not(subj1 == subj2 or subj1 == obj2 or obj1 == subj2 or obj1 == obj2): return False

        return True
            
        
class RDFInferenceSystem(object):
    def __init__(self, dataset):
        self.dataset = dataset

class PPInferenceSystem(RDFInferenceSystem):
    def __init__(self, dataset):
        super(PPInferenceSystem, self).__init__(dataset)

    def train(self):
        pass

    def reason(self, subj=None, pred=None, obj=None):
        """
        return triples which are likely to hold in the dataset 
        """
        triples = []
        return triples

    def propagation(self, n, m, subj_q, pred_q, obj_q):
        if n == 0: return int((subj_q, pred_q, obj_q) in self.dataset)

        sum_propagation_value = 0
        for _, pred_t, obj_t in self.dataset.triples((subj_q,  None, None)):
            concept_path_set = self.get_concept_path_set_s(m, subj_q, pred_t, obj_t)
            for concept, path in concept_path_set:
                sum_propagation_value += self.propagation(n-1,m, concept, pred_q, obj_q) * self.get_weight(path)

        return sum_propagation_value

    #書いてる途中
    def get_weight(self, path, a, f):
        if len(path) == 1:
            #number_of_members = self.dataset.triples((None, pred, obj))
        return float(a) / f(number_of_members)

    def get_concept_path_set_s_0(self, subj, pred, obj, path_default=[], path_obj=None):
        concept_path_set = []

        for concept, pred_s, obj_s in self.dataset.triples((None, pred, obj)):
            # this condition is only for 1-order path
            if len(path_default) == 0:
                if (subj, pred_s, obj_s) not in self.dataset:
                    continue
            if concept == subj: continue

            # when path is one-order, obj of path is always obj_s
            if path_obj == None: path_obj = obj_s

            path = [(subj, pred_s, path_obj)] + path_default + [(concept, pred_s, obj_s)]
            concept_path = (concept, path)

            if concept_path in concept_path_set: continue

            concept_path_set.append((concept, path))

        return concept_path_set

    def get_concept_path_set_s(self, m, subj, pred=None, obj=None):
        concept_path_set = []

        if m == 1:
            concept_path_set = self.get_concept_path_set_s_0(subj, pred, obj)
        else:
            concept_prime_set = self.get_concept_path_set_s(m-1, obj, None, None)
            for concept_prime, path_prime in concept_prime_set:
                concept_path_set = self.get_concept_path_set_s_0(subj, pred, concept_prime, path_prime, obj)

            # unify with the concept set with lower order
            lower_order_set = self.get_concept_path_set_s(m-1, subj, pred, obj)
            concept_path_set = self.unify_concept_path_set(concept_path_set, lower_order_set)

        return concept_path_set

    def unify_concept_path_set(self,present_set, new_set):
        for new_concept_path in new_set:
            if new_concept_path not in present_set: present_set.append(new_concept_path)
        return present_set

    def retrieve(self, subj=None, pred=None, obj=None):
        """
        return triples which are true in the dataset
        """
        return self.dataset.triples((subj, pred, obj))

    def print_dataset():
        print_graph(self.dataset)

    
if __name__ == "__main__":

    rg = GraphController()
    rg.construct_graph('dataset/en/rdf/')
    dataset = rg.graph

    inference_system = PPInferenceSystem(dataset)    

    print_graph(dataset)

